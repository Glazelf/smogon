#!/usr/bin/env node
'use strict';

try {
  require('source-map-support').install();
} catch (err) {
  if (err.code !== 'MODULE_NOT_FOUND') throw err;
}

// Creates an index file with the size of Pokémon Showdonw's assets for each generation.
// BUG: Pokémon Showdown actually copies sprites redundantly when it shouldn't, so something like
// `gen2g` contains `gen2` assets for the Pokémon that didn't receive unique sprites in Gold. This
// is useful for simplicity but results it useless duplicate information being fetched.

const fs = require('fs');
const path = require('path');
const probe = require('probe-image-size');
const fetch = require('node-fetch');
const stringify = require('json-stringify-pretty-compact');

const size = retrying(throttling(async (url) => {
  try {
    return probe(url);
  } catch (err) {
    if (err.message.startsWith('HTTP')) {
      throw err;
    } else {
      throw new RetryableError(err.message);
    }
  }
}, 1, 50), 5, 20);

const ASSETS = {
  default: [
    'gen5-back-shiny', 'gen5-back', 'gen5-shiny', 'gen5',
    'substitutes/gen5-back', 'substitutes/gen5',
    'trainers', 'types',
    'pokemonicons-sheet.png', 'pokemonicons-pokeball-sheet.png', 'itemicons-sheet.png',
  ],
  gen1: ['gen1-back', 'gen1', 'substitutes/gen1-back', 'substitutes/gen1'],
  gen1rb: ['gen1rb'],
  gen1rg: ['gen1rg'],
  gen2: ['gen2-back-shiny', 'gen2-back', 'gen2-shiny', 'gen2'],
  gen2g: ['gen2g'],
  gen2s: [ 'gen2s'],
  gen3: [
    'gen3-back-shiny', 'gen3-back', 'gen3-shiny', 'gen3',
    'substitutes/gen3-back', 'substitutes/gen3',
  ],
  gen3rs: ['gen3rs-shiny', 'gen3rs'],
  gen3frlg: ['gen3frlg'],
  gen4: [
    'gen4-back-shiny', 'gen4-back', 'gen4-shiny', 'gen4',
    'substitutes/gen4-back', 'substitutes/gen4',
  ],
  gen4dp: ['gen4dp-shiny', 'gen4dp'],
  gen5ani: [ 'gen5ani-back-shiny', 'gen5ani-back', 'gen5ani-shiny', 'gen5ani'],
  ani: ['ani-back-shiny', 'ani-back', 'ani-shiny', 'ani'],
  dex: ['dex-shiny', 'dex'],
};

const DATA = path.resolve(__dirname, '../data');
try { fs.unlinkSync(path.join(DATA, 'imgs', 'index.json')); } catch {}

const MAX = +process.argv[2] || 50;
const URL = 'https://play.pokemonshowdown.com/sprites';
const HREF = /href="(.*?\.(png|gif))"/;

(async () => {
  const index = {};
  for (const source in ASSETS) {
    index[source] = 0;
    for (const asset of ASSETS[source]) {
      if (asset.endsWith('png')) {
        index[source] += (await probe(`${URL}/${asset}`)).length;
      } else {
        const page = await (await fetch(`${URL}/${asset}`)).text();
        let imgs = [];
        for (const line of page.split('\n')) {
          const m = HREF.exec(line);
          if (m) imgs.push(size(`${URL}/${asset}/${m[1]}`));
          if (imgs.length >= MAX) {
            for (const img of await Promise.all(imgs)) {
              index[source] += img.length;
            }
            imgs = [];
          }
        }
        for (const img of await Promise.all(imgs)) {
          index[source] += img.length;
        }
      }
    }
  }

  fs.writeFileSync(path.join(DATA, 'imgs', 'index.json'), stringify(index));
})().catch(err => {
  console.error(err);
  process.exit(1);
});

class RetryableError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

function retrying(fn, retries, wait) {
  const retry = async (args, attempt) => {
    try {
      return await fn(args);
    } catch (err) {
      if (err instanceof RetryableError) {
        attempt++;
        if (attempt > retries) return Promise.reject(err);
        const timeout = Math.round(attempt * wait * (1 + Math.random() / 2));
        return new Promise(resolve => {
          setTimeout(() => {
            resolve(retry(args, attempt++));
          }, timeout);
        });
      } else {
        return Promise.reject(err);
      }
    }
  };
  return retry;
}

function throttling(fn, limit, interval) {
  const queue = new Map();
  let currentTick = 0;
  let activeCount = 0;

  const throttled = (args) => {
    let timeout;
    return new Promise((resolve, reject) => {
      const execute = () => {
        resolve(fn(args))
        queue.delete(timeout);
      };

      const now = Date.now();

      if (now - currentTick > interval) {
        activeCount = 1;
        currentTick = now;
      } else if (activeCount < limit) {
        activeCount++;
      } else {
        currentTick += interval;
        activeCount = 1;
      }

      timeout = setTimeout(execute, currentTick - now);
      queue.set(timeout, reject);
    });
  };

  return throttled;
}
